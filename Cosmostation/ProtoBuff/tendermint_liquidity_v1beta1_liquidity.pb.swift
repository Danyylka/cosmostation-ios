// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tendermint/liquidity/v1beta1/liquidity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Structure for the pool type to distinguish the characteristics of the reserve pools.
struct Tendermint_Liquidity_V1beta1_PoolType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the id of the pool_type that is used as pool_type_id for pool creation.
  /// In this version, only pool-type-id 1 is supported.
  /// {"id":1,"name":"ConstantProductLiquidityPool","min_reserve_coin_num":2,"max_reserve_coin_num":2,"description":""}
  var id: UInt32 = 0

  /// name of the pool type.
  var name: String = String()

  /// minimum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
  var minReserveCoinNum: UInt32 = 0

  /// maximum number of reserveCoins for LiquidityPoolType, only 2 reserve coins are supported.
  var maxReserveCoinNum: UInt32 = 0

  /// description of the pool type.
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Params defines the parameters for the liquidity module.
struct Tendermint_Liquidity_V1beta1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// list of available pool types
  var poolTypes: [Tendermint_Liquidity_V1beta1_PoolType] = []

  /// Minimum number of coins to be deposited to the liquidity pool on pool creation.
  var minInitDepositAmount: String = String()

  /// Initial mint amount of pool coins upon pool creation.
  var initPoolCoinMintAmount: String = String()

  /// Limit the size of each liquidity pool to minimize risk. In development, set to 0 for no limit. In production, set a limit.
  var maxReserveCoinAmount: String = String()

  /// Fee paid to create a Liquidity Pool. Set a fee to prevent spamming.
  var poolCreationFee: [Cosmos_Base_V1beta1_Coin] = []

  /// Swap fee rate for every executed swap.
  var swapFeeRate: String = String()

  /// Reserve coin withdrawal with less proportion by withdrawFeeRate.
  var withdrawFeeRate: String = String()

  /// Maximum ratio of reserve coins that can be ordered at a swap order.
  var maxOrderAmountRatio: String = String()

  /// The smallest unit batch height for every liquidity pool.
  var unitBatchHeight: UInt32 = 0

  /// Circuit breaker enables or disables transaction messages in liquidity module.
  var circuitBreakerEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Pool defines the liquidity pool that contains pool information.
struct Tendermint_Liquidity_V1beta1_Pool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the pool
  var id: UInt64 = 0

  /// id of the pool_type
  var typeID: UInt32 = 0

  /// denoms of reserve coin pair of the pool
  var reserveCoinDenoms: [String] = []

  /// reserve account address of the pool
  var reserveAccountAddress: String = String()

  /// denom of pool coin of the pool
  var poolCoinDenom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Metadata for the state of each pool for invariant checking after genesis export or import.
struct Tendermint_Liquidity_V1beta1_PoolMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the pool
  var poolID: UInt64 = 0

  /// pool coin issued at the pool
  var poolCoinTotalSupply: Cosmos_Base_V1beta1_Coin {
    get {return _poolCoinTotalSupply ?? Cosmos_Base_V1beta1_Coin()}
    set {_poolCoinTotalSupply = newValue}
  }
  /// Returns true if `poolCoinTotalSupply` has been explicitly set.
  var hasPoolCoinTotalSupply: Bool {return self._poolCoinTotalSupply != nil}
  /// Clears the value of `poolCoinTotalSupply`. Subsequent reads from it will return its default value.
  mutating func clearPoolCoinTotalSupply() {self._poolCoinTotalSupply = nil}

  /// reserve coins deposited in the pool
  var reserveCoins: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _poolCoinTotalSupply: Cosmos_Base_V1beta1_Coin? = nil
}

/// PoolBatch defines the batch or batches of a given liquidity pool that contains indexes of deposit, withdraw, and swap messages. 
/// Index param increments by 1 if the pool id is same.
struct Tendermint_Liquidity_V1beta1_PoolBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the pool
  var poolID: UInt64 = 0

  /// index of this batch
  var index: UInt64 = 0

  /// height where this batch is started
  var beginHeight: Int64 = 0

  /// last index of DepositMsgStates
  var depositMsgIndex: UInt64 = 0

  /// last index of WithdrawMsgStates
  var withdrawMsgIndex: UInt64 = 0

  /// last index of SwapMsgStates
  var swapMsgIndex: UInt64 = 0

  /// true if executed, false if not executed 
  var executed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DepositMsgState defines the state of deposit message that contains state information as it is processed in the next batch or batches.
struct Tendermint_Liquidity_V1beta1_DepositMsgState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height where this message is appended to the batch
  var msgHeight: Int64 = 0

  /// index of this deposit message in this liquidity pool
  var msgIndex: UInt64 = 0

  /// true if executed on this batch, false if not executed 
  var executed: Bool = false

  /// true if executed successfully on this batch, false if failed
  var succeeded: Bool = false

  /// true if ready to be deleted on kvstore, false if not ready to be deleted
  var toBeDeleted: Bool = false

  /// MsgDepositWithinBatch
  var msg: Tendermint_Liquidity_V1beta1_MsgDepositWithinBatch {
    get {return _msg ?? Tendermint_Liquidity_V1beta1_MsgDepositWithinBatch()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {self._msg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _msg: Tendermint_Liquidity_V1beta1_MsgDepositWithinBatch? = nil
}

/// WithdrawMsgState defines the state of the withdraw message that contains state information as the message is processed in the next batch or batches.
struct Tendermint_Liquidity_V1beta1_WithdrawMsgState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height where this message is appended to the batch
  var msgHeight: Int64 = 0

  /// index of this withdraw message in this liquidity pool
  var msgIndex: UInt64 = 0

  /// true if executed on this batch, false if not executed 
  var executed: Bool = false

  /// true if executed successfully on this batch, false if failed
  var succeeded: Bool = false

  /// true if ready to be deleted on kvstore, false if not ready to be deleted
  var toBeDeleted: Bool = false

  /// MsgWithdrawWithinBatch
  var msg: Tendermint_Liquidity_V1beta1_MsgWithdrawWithinBatch {
    get {return _msg ?? Tendermint_Liquidity_V1beta1_MsgWithdrawWithinBatch()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {self._msg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _msg: Tendermint_Liquidity_V1beta1_MsgWithdrawWithinBatch? = nil
}

/// SwapMsgState defines the state of the swap message that contains state information as the message is processed in the next batch or batches.
struct Tendermint_Liquidity_V1beta1_SwapMsgState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// height where this message is appended to the batch
  var msgHeight: Int64 = 0

  /// index of this swap message in this liquidity pool
  var msgIndex: UInt64 = 0

  /// true if executed on this batch, false if not executed 
  var executed: Bool = false

  /// true if executed successfully on this batch, false if failed
  var succeeded: Bool = false

  /// true if ready to be deleted on kvstore, false if not ready to be deleted
  var toBeDeleted: Bool = false

  /// swap orders are cancelled when current height is equal to or higher than ExpiryHeight
  var orderExpiryHeight: Int64 = 0

  /// offer coin exchanged until now
  var exchangedOfferCoin: Cosmos_Base_V1beta1_Coin {
    get {return _exchangedOfferCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_exchangedOfferCoin = newValue}
  }
  /// Returns true if `exchangedOfferCoin` has been explicitly set.
  var hasExchangedOfferCoin: Bool {return self._exchangedOfferCoin != nil}
  /// Clears the value of `exchangedOfferCoin`. Subsequent reads from it will return its default value.
  mutating func clearExchangedOfferCoin() {self._exchangedOfferCoin = nil}

  /// offer coin currently remaining to be exchanged
  var remainingOfferCoin: Cosmos_Base_V1beta1_Coin {
    get {return _remainingOfferCoin ?? Cosmos_Base_V1beta1_Coin()}
    set {_remainingOfferCoin = newValue}
  }
  /// Returns true if `remainingOfferCoin` has been explicitly set.
  var hasRemainingOfferCoin: Bool {return self._remainingOfferCoin != nil}
  /// Clears the value of `remainingOfferCoin`. Subsequent reads from it will return its default value.
  mutating func clearRemainingOfferCoin() {self._remainingOfferCoin = nil}

  /// reserve fee for pays fee in half offer coin
  var reservedOfferCoinFee: Cosmos_Base_V1beta1_Coin {
    get {return _reservedOfferCoinFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_reservedOfferCoinFee = newValue}
  }
  /// Returns true if `reservedOfferCoinFee` has been explicitly set.
  var hasReservedOfferCoinFee: Bool {return self._reservedOfferCoinFee != nil}
  /// Clears the value of `reservedOfferCoinFee`. Subsequent reads from it will return its default value.
  mutating func clearReservedOfferCoinFee() {self._reservedOfferCoinFee = nil}

  /// MsgSwapWithinBatch
  var msg: Tendermint_Liquidity_V1beta1_MsgSwapWithinBatch {
    get {return _msg ?? Tendermint_Liquidity_V1beta1_MsgSwapWithinBatch()}
    set {_msg = newValue}
  }
  /// Returns true if `msg` has been explicitly set.
  var hasMsg: Bool {return self._msg != nil}
  /// Clears the value of `msg`. Subsequent reads from it will return its default value.
  mutating func clearMsg() {self._msg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _exchangedOfferCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _remainingOfferCoin: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _reservedOfferCoinFee: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _msg: Tendermint_Liquidity_V1beta1_MsgSwapWithinBatch? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tendermint.liquidity.v1beta1"

extension Tendermint_Liquidity_V1beta1_PoolType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "min_reserve_coin_num"),
    4: .standard(proto: "max_reserve_coin_num"),
    5: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.minReserveCoinNum)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.maxReserveCoinNum)
      case 5: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.minReserveCoinNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.minReserveCoinNum, fieldNumber: 3)
    }
    if self.maxReserveCoinNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxReserveCoinNum, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_PoolType, rhs: Tendermint_Liquidity_V1beta1_PoolType) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.minReserveCoinNum != rhs.minReserveCoinNum {return false}
    if lhs.maxReserveCoinNum != rhs.maxReserveCoinNum {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_types"),
    2: .standard(proto: "min_init_deposit_amount"),
    3: .standard(proto: "init_pool_coin_mint_amount"),
    4: .standard(proto: "max_reserve_coin_amount"),
    5: .standard(proto: "pool_creation_fee"),
    6: .standard(proto: "swap_fee_rate"),
    7: .standard(proto: "withdraw_fee_rate"),
    8: .standard(proto: "max_order_amount_ratio"),
    9: .standard(proto: "unit_batch_height"),
    10: .standard(proto: "circuit_breaker_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.poolTypes)
      case 2: try decoder.decodeSingularStringField(value: &self.minInitDepositAmount)
      case 3: try decoder.decodeSingularStringField(value: &self.initPoolCoinMintAmount)
      case 4: try decoder.decodeSingularStringField(value: &self.maxReserveCoinAmount)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.poolCreationFee)
      case 6: try decoder.decodeSingularStringField(value: &self.swapFeeRate)
      case 7: try decoder.decodeSingularStringField(value: &self.withdrawFeeRate)
      case 8: try decoder.decodeSingularStringField(value: &self.maxOrderAmountRatio)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.unitBatchHeight)
      case 10: try decoder.decodeSingularBoolField(value: &self.circuitBreakerEnabled)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.poolTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolTypes, fieldNumber: 1)
    }
    if !self.minInitDepositAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.minInitDepositAmount, fieldNumber: 2)
    }
    if !self.initPoolCoinMintAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.initPoolCoinMintAmount, fieldNumber: 3)
    }
    if !self.maxReserveCoinAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.maxReserveCoinAmount, fieldNumber: 4)
    }
    if !self.poolCreationFee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.poolCreationFee, fieldNumber: 5)
    }
    if !self.swapFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.swapFeeRate, fieldNumber: 6)
    }
    if !self.withdrawFeeRate.isEmpty {
      try visitor.visitSingularStringField(value: self.withdrawFeeRate, fieldNumber: 7)
    }
    if !self.maxOrderAmountRatio.isEmpty {
      try visitor.visitSingularStringField(value: self.maxOrderAmountRatio, fieldNumber: 8)
    }
    if self.unitBatchHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.unitBatchHeight, fieldNumber: 9)
    }
    if self.circuitBreakerEnabled != false {
      try visitor.visitSingularBoolField(value: self.circuitBreakerEnabled, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_Params, rhs: Tendermint_Liquidity_V1beta1_Params) -> Bool {
    if lhs.poolTypes != rhs.poolTypes {return false}
    if lhs.minInitDepositAmount != rhs.minInitDepositAmount {return false}
    if lhs.initPoolCoinMintAmount != rhs.initPoolCoinMintAmount {return false}
    if lhs.maxReserveCoinAmount != rhs.maxReserveCoinAmount {return false}
    if lhs.poolCreationFee != rhs.poolCreationFee {return false}
    if lhs.swapFeeRate != rhs.swapFeeRate {return false}
    if lhs.withdrawFeeRate != rhs.withdrawFeeRate {return false}
    if lhs.maxOrderAmountRatio != rhs.maxOrderAmountRatio {return false}
    if lhs.unitBatchHeight != rhs.unitBatchHeight {return false}
    if lhs.circuitBreakerEnabled != rhs.circuitBreakerEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_Pool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pool"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "type_id"),
    3: .standard(proto: "reserve_coin_denoms"),
    4: .standard(proto: "reserve_account_address"),
    5: .standard(proto: "pool_coin_denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.typeID)
      case 3: try decoder.decodeRepeatedStringField(value: &self.reserveCoinDenoms)
      case 4: try decoder.decodeSingularStringField(value: &self.reserveAccountAddress)
      case 5: try decoder.decodeSingularStringField(value: &self.poolCoinDenom)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.typeID != 0 {
      try visitor.visitSingularUInt32Field(value: self.typeID, fieldNumber: 2)
    }
    if !self.reserveCoinDenoms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reserveCoinDenoms, fieldNumber: 3)
    }
    if !self.reserveAccountAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.reserveAccountAddress, fieldNumber: 4)
    }
    if !self.poolCoinDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.poolCoinDenom, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_Pool, rhs: Tendermint_Liquidity_V1beta1_Pool) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.typeID != rhs.typeID {return false}
    if lhs.reserveCoinDenoms != rhs.reserveCoinDenoms {return false}
    if lhs.reserveAccountAddress != rhs.reserveAccountAddress {return false}
    if lhs.poolCoinDenom != rhs.poolCoinDenom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_PoolMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .standard(proto: "pool_coin_total_supply"),
    3: .standard(proto: "reserve_coins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.poolID)
      case 2: try decoder.decodeSingularMessageField(value: &self._poolCoinTotalSupply)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.reserveCoins)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if let v = self._poolCoinTotalSupply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.reserveCoins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reserveCoins, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_PoolMetadata, rhs: Tendermint_Liquidity_V1beta1_PoolMetadata) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs._poolCoinTotalSupply != rhs._poolCoinTotalSupply {return false}
    if lhs.reserveCoins != rhs.reserveCoins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_PoolBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoolBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pool_id"),
    2: .same(proto: "index"),
    3: .standard(proto: "begin_height"),
    4: .standard(proto: "deposit_msg_index"),
    5: .standard(proto: "withdraw_msg_index"),
    6: .standard(proto: "swap_msg_index"),
    7: .same(proto: "executed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.poolID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.index)
      case 3: try decoder.decodeSingularInt64Field(value: &self.beginHeight)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.depositMsgIndex)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.withdrawMsgIndex)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.swapMsgIndex)
      case 7: try decoder.decodeSingularBoolField(value: &self.executed)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.poolID != 0 {
      try visitor.visitSingularUInt64Field(value: self.poolID, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 2)
    }
    if self.beginHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.beginHeight, fieldNumber: 3)
    }
    if self.depositMsgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.depositMsgIndex, fieldNumber: 4)
    }
    if self.withdrawMsgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.withdrawMsgIndex, fieldNumber: 5)
    }
    if self.swapMsgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.swapMsgIndex, fieldNumber: 6)
    }
    if self.executed != false {
      try visitor.visitSingularBoolField(value: self.executed, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_PoolBatch, rhs: Tendermint_Liquidity_V1beta1_PoolBatch) -> Bool {
    if lhs.poolID != rhs.poolID {return false}
    if lhs.index != rhs.index {return false}
    if lhs.beginHeight != rhs.beginHeight {return false}
    if lhs.depositMsgIndex != rhs.depositMsgIndex {return false}
    if lhs.withdrawMsgIndex != rhs.withdrawMsgIndex {return false}
    if lhs.swapMsgIndex != rhs.swapMsgIndex {return false}
    if lhs.executed != rhs.executed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_DepositMsgState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DepositMsgState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_height"),
    2: .standard(proto: "msg_index"),
    3: .same(proto: "executed"),
    4: .same(proto: "succeeded"),
    5: .standard(proto: "to_be_deleted"),
    6: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.msgHeight)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.msgIndex)
      case 3: try decoder.decodeSingularBoolField(value: &self.executed)
      case 4: try decoder.decodeSingularBoolField(value: &self.succeeded)
      case 5: try decoder.decodeSingularBoolField(value: &self.toBeDeleted)
      case 6: try decoder.decodeSingularMessageField(value: &self._msg)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 1)
    }
    if self.msgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgIndex, fieldNumber: 2)
    }
    if self.executed != false {
      try visitor.visitSingularBoolField(value: self.executed, fieldNumber: 3)
    }
    if self.succeeded != false {
      try visitor.visitSingularBoolField(value: self.succeeded, fieldNumber: 4)
    }
    if self.toBeDeleted != false {
      try visitor.visitSingularBoolField(value: self.toBeDeleted, fieldNumber: 5)
    }
    if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_DepositMsgState, rhs: Tendermint_Liquidity_V1beta1_DepositMsgState) -> Bool {
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.msgIndex != rhs.msgIndex {return false}
    if lhs.executed != rhs.executed {return false}
    if lhs.succeeded != rhs.succeeded {return false}
    if lhs.toBeDeleted != rhs.toBeDeleted {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_WithdrawMsgState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WithdrawMsgState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_height"),
    2: .standard(proto: "msg_index"),
    3: .same(proto: "executed"),
    4: .same(proto: "succeeded"),
    5: .standard(proto: "to_be_deleted"),
    6: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.msgHeight)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.msgIndex)
      case 3: try decoder.decodeSingularBoolField(value: &self.executed)
      case 4: try decoder.decodeSingularBoolField(value: &self.succeeded)
      case 5: try decoder.decodeSingularBoolField(value: &self.toBeDeleted)
      case 6: try decoder.decodeSingularMessageField(value: &self._msg)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 1)
    }
    if self.msgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgIndex, fieldNumber: 2)
    }
    if self.executed != false {
      try visitor.visitSingularBoolField(value: self.executed, fieldNumber: 3)
    }
    if self.succeeded != false {
      try visitor.visitSingularBoolField(value: self.succeeded, fieldNumber: 4)
    }
    if self.toBeDeleted != false {
      try visitor.visitSingularBoolField(value: self.toBeDeleted, fieldNumber: 5)
    }
    if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_WithdrawMsgState, rhs: Tendermint_Liquidity_V1beta1_WithdrawMsgState) -> Bool {
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.msgIndex != rhs.msgIndex {return false}
    if lhs.executed != rhs.executed {return false}
    if lhs.succeeded != rhs.succeeded {return false}
    if lhs.toBeDeleted != rhs.toBeDeleted {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Liquidity_V1beta1_SwapMsgState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SwapMsgState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_height"),
    2: .standard(proto: "msg_index"),
    3: .same(proto: "executed"),
    4: .same(proto: "succeeded"),
    5: .standard(proto: "to_be_deleted"),
    6: .standard(proto: "order_expiry_height"),
    7: .standard(proto: "exchanged_offer_coin"),
    8: .standard(proto: "remaining_offer_coin"),
    9: .standard(proto: "reserved_offer_coin_fee"),
    10: .same(proto: "msg"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.msgHeight)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.msgIndex)
      case 3: try decoder.decodeSingularBoolField(value: &self.executed)
      case 4: try decoder.decodeSingularBoolField(value: &self.succeeded)
      case 5: try decoder.decodeSingularBoolField(value: &self.toBeDeleted)
      case 6: try decoder.decodeSingularInt64Field(value: &self.orderExpiryHeight)
      case 7: try decoder.decodeSingularMessageField(value: &self._exchangedOfferCoin)
      case 8: try decoder.decodeSingularMessageField(value: &self._remainingOfferCoin)
      case 9: try decoder.decodeSingularMessageField(value: &self._reservedOfferCoinFee)
      case 10: try decoder.decodeSingularMessageField(value: &self._msg)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.msgHeight, fieldNumber: 1)
    }
    if self.msgIndex != 0 {
      try visitor.visitSingularUInt64Field(value: self.msgIndex, fieldNumber: 2)
    }
    if self.executed != false {
      try visitor.visitSingularBoolField(value: self.executed, fieldNumber: 3)
    }
    if self.succeeded != false {
      try visitor.visitSingularBoolField(value: self.succeeded, fieldNumber: 4)
    }
    if self.toBeDeleted != false {
      try visitor.visitSingularBoolField(value: self.toBeDeleted, fieldNumber: 5)
    }
    if self.orderExpiryHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.orderExpiryHeight, fieldNumber: 6)
    }
    if let v = self._exchangedOfferCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._remainingOfferCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._reservedOfferCoinFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._msg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Liquidity_V1beta1_SwapMsgState, rhs: Tendermint_Liquidity_V1beta1_SwapMsgState) -> Bool {
    if lhs.msgHeight != rhs.msgHeight {return false}
    if lhs.msgIndex != rhs.msgIndex {return false}
    if lhs.executed != rhs.executed {return false}
    if lhs.succeeded != rhs.succeeded {return false}
    if lhs.toBeDeleted != rhs.toBeDeleted {return false}
    if lhs.orderExpiryHeight != rhs.orderExpiryHeight {return false}
    if lhs._exchangedOfferCoin != rhs._exchangedOfferCoin {return false}
    if lhs._remainingOfferCoin != rhs._remainingOfferCoin {return false}
    if lhs._reservedOfferCoinFee != rhs._reservedOfferCoinFee {return false}
    if lhs._msg != rhs._msg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

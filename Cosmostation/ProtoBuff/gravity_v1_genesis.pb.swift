// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gravity/v1/genesis.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Params represent the Gravity genesis and store parameters
/// gravity_id:
/// a random 32 byte value to prevent signature reuse, for example if the
/// cosmos validators decided to use the same Ethereum keys for another chain
/// also running Gravity we would not want it to be possible to play a deposit
/// from chain A back on chain B's Gravity. This value IS USED ON ETHEREUM so
/// it must be set in your genesis.json before launch and not changed after
/// deploying Gravity
///
/// contract_hash:
/// the code hash of a known good version of the Gravity contract
/// solidity code. This can be used to verify the correct version
/// of the contract has been deployed. This is a reference value for
/// goernance action only it is never read by any Gravity code
///
/// bridge_ethereum_address:
/// is address of the bridge contract on the Ethereum side, this is a
/// reference value for governance only and is not actually used by any
/// Gravity code
///
/// bridge_chain_id:
/// the unique identifier of the Ethereum chain, this is a reference value
/// only and is not actually used by any Gravity code
///
/// These reference values may be used by future Gravity client implemetnations
/// to allow for saftey features or convenience features like the Gravity address
/// in your relayer. A relayer would require a configured Gravity address if
/// governance had not set the address on the chain it was relaying for.
///
/// signed_valsets_window
/// signed_batches_window
/// signed_claims_window
///
/// These values represent the time in blocks that a validator has to submit
/// a signature for a batch or valset, or to submit a claim for a particular
/// attestation nonce. In the case of attestations this clock starts when the
/// attestation is created, but only allows for slashing once the event has passed
///
/// target_batch_timeout:
///
/// This is the 'target' value for when batches time out, this is a target becuase
/// Ethereum is a probabalistic chain and you can't say for sure what the block
/// frequency is ahead of time.
///
/// average_block_time
/// average_ethereum_block_time
///
/// These values are the average Cosmos block time and Ethereum block time repsectively
/// and they are used to copute what the target batch timeout is. It is important that
/// governance updates these in case of any major, prolonged change in the time it takes
/// to produce a block
///
/// slash_fraction_valset
/// slash_fraction_batch
/// slash_fraction_claim
/// slash_fraction_conflicting_claim
///
/// The slashing fractions for the various gravity related slashing conditions. The first three
/// refer to not submitting a particular message, the third for submitting a different claim
/// for the same Ethereum event
struct Gravity_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gravityID: String = String()

  var contractSourceHash: String = String()

  var bridgeEthereumAddress: String = String()

  var bridgeChainID: UInt64 = 0

  var signedValsetsWindow: UInt64 = 0

  var signedBatchesWindow: UInt64 = 0

  var signedClaimsWindow: UInt64 = 0

  var targetBatchTimeout: UInt64 = 0

  var averageBlockTime: UInt64 = 0

  var averageEthereumBlockTime: UInt64 = 0

  var slashFractionValset: Data = SwiftProtobuf.Internal.emptyData

  var slashFractionBatch: Data = SwiftProtobuf.Internal.emptyData

  var slashFractionClaim: Data = SwiftProtobuf.Internal.emptyData

  var slashFractionConflictingClaim: Data = SwiftProtobuf.Internal.emptyData

  var unbondSlashingValsetsWindow: UInt64 = 0

  var slashFractionBadEthSignature: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GenesisState struct
struct Gravity_V1_GenesisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: Gravity_V1_Params {
    get {return _params ?? Gravity_V1_Params()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  mutating func clearParams() {self._params = nil}

  var lastObservedNonce: UInt64 = 0

  var valsets: [Gravity_V1_Valset] = []

  var valsetConfirms: [Gravity_V1_MsgValsetConfirm] = []

  var batches: [Gravity_V1_OutgoingTxBatch] = []

  var batchConfirms: [Gravity_V1_MsgConfirmBatch] = []

  var logicCalls: [Gravity_V1_OutgoingLogicCall] = []

  var logicCallConfirms: [Gravity_V1_MsgConfirmLogicCall] = []

  var attestations: [Gravity_V1_Attestation] = []

  var delegateKeys: [Gravity_V1_MsgSetOrchestratorAddress] = []

  var erc20ToDenoms: [Gravity_V1_ERC20ToDenom] = []

  var unbatchedTransfers: [Gravity_V1_OutgoingTransferTx] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _params: Gravity_V1_Params? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "gravity.v1"

extension Gravity_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gravity_id"),
    2: .standard(proto: "contract_source_hash"),
    4: .standard(proto: "bridge_ethereum_address"),
    5: .standard(proto: "bridge_chain_id"),
    6: .standard(proto: "signed_valsets_window"),
    7: .standard(proto: "signed_batches_window"),
    8: .standard(proto: "signed_claims_window"),
    10: .standard(proto: "target_batch_timeout"),
    11: .standard(proto: "average_block_time"),
    12: .standard(proto: "average_ethereum_block_time"),
    13: .standard(proto: "slash_fraction_valset"),
    14: .standard(proto: "slash_fraction_batch"),
    15: .standard(proto: "slash_fraction_claim"),
    16: .standard(proto: "slash_fraction_conflicting_claim"),
    17: .standard(proto: "unbond_slashing_valsets_window"),
    18: .standard(proto: "slash_fraction_bad_eth_signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.gravityID)
      case 2: try decoder.decodeSingularStringField(value: &self.contractSourceHash)
      case 4: try decoder.decodeSingularStringField(value: &self.bridgeEthereumAddress)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.bridgeChainID)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.signedValsetsWindow)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.signedBatchesWindow)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.signedClaimsWindow)
      case 10: try decoder.decodeSingularUInt64Field(value: &self.targetBatchTimeout)
      case 11: try decoder.decodeSingularUInt64Field(value: &self.averageBlockTime)
      case 12: try decoder.decodeSingularUInt64Field(value: &self.averageEthereumBlockTime)
      case 13: try decoder.decodeSingularBytesField(value: &self.slashFractionValset)
      case 14: try decoder.decodeSingularBytesField(value: &self.slashFractionBatch)
      case 15: try decoder.decodeSingularBytesField(value: &self.slashFractionClaim)
      case 16: try decoder.decodeSingularBytesField(value: &self.slashFractionConflictingClaim)
      case 17: try decoder.decodeSingularUInt64Field(value: &self.unbondSlashingValsetsWindow)
      case 18: try decoder.decodeSingularBytesField(value: &self.slashFractionBadEthSignature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gravityID.isEmpty {
      try visitor.visitSingularStringField(value: self.gravityID, fieldNumber: 1)
    }
    if !self.contractSourceHash.isEmpty {
      try visitor.visitSingularStringField(value: self.contractSourceHash, fieldNumber: 2)
    }
    if !self.bridgeEthereumAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.bridgeEthereumAddress, fieldNumber: 4)
    }
    if self.bridgeChainID != 0 {
      try visitor.visitSingularUInt64Field(value: self.bridgeChainID, fieldNumber: 5)
    }
    if self.signedValsetsWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.signedValsetsWindow, fieldNumber: 6)
    }
    if self.signedBatchesWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.signedBatchesWindow, fieldNumber: 7)
    }
    if self.signedClaimsWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.signedClaimsWindow, fieldNumber: 8)
    }
    if self.targetBatchTimeout != 0 {
      try visitor.visitSingularUInt64Field(value: self.targetBatchTimeout, fieldNumber: 10)
    }
    if self.averageBlockTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.averageBlockTime, fieldNumber: 11)
    }
    if self.averageEthereumBlockTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.averageEthereumBlockTime, fieldNumber: 12)
    }
    if !self.slashFractionValset.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionValset, fieldNumber: 13)
    }
    if !self.slashFractionBatch.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionBatch, fieldNumber: 14)
    }
    if !self.slashFractionClaim.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionClaim, fieldNumber: 15)
    }
    if !self.slashFractionConflictingClaim.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionConflictingClaim, fieldNumber: 16)
    }
    if self.unbondSlashingValsetsWindow != 0 {
      try visitor.visitSingularUInt64Field(value: self.unbondSlashingValsetsWindow, fieldNumber: 17)
    }
    if !self.slashFractionBadEthSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.slashFractionBadEthSignature, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_Params, rhs: Gravity_V1_Params) -> Bool {
    if lhs.gravityID != rhs.gravityID {return false}
    if lhs.contractSourceHash != rhs.contractSourceHash {return false}
    if lhs.bridgeEthereumAddress != rhs.bridgeEthereumAddress {return false}
    if lhs.bridgeChainID != rhs.bridgeChainID {return false}
    if lhs.signedValsetsWindow != rhs.signedValsetsWindow {return false}
    if lhs.signedBatchesWindow != rhs.signedBatchesWindow {return false}
    if lhs.signedClaimsWindow != rhs.signedClaimsWindow {return false}
    if lhs.targetBatchTimeout != rhs.targetBatchTimeout {return false}
    if lhs.averageBlockTime != rhs.averageBlockTime {return false}
    if lhs.averageEthereumBlockTime != rhs.averageEthereumBlockTime {return false}
    if lhs.slashFractionValset != rhs.slashFractionValset {return false}
    if lhs.slashFractionBatch != rhs.slashFractionBatch {return false}
    if lhs.slashFractionClaim != rhs.slashFractionClaim {return false}
    if lhs.slashFractionConflictingClaim != rhs.slashFractionConflictingClaim {return false}
    if lhs.unbondSlashingValsetsWindow != rhs.unbondSlashingValsetsWindow {return false}
    if lhs.slashFractionBadEthSignature != rhs.slashFractionBadEthSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_GenesisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenesisState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .standard(proto: "last_observed_nonce"),
    3: .same(proto: "valsets"),
    4: .standard(proto: "valset_confirms"),
    5: .same(proto: "batches"),
    6: .standard(proto: "batch_confirms"),
    7: .standard(proto: "logic_calls"),
    8: .standard(proto: "logic_call_confirms"),
    9: .same(proto: "attestations"),
    10: .standard(proto: "delegate_keys"),
    11: .standard(proto: "erc20_to_denoms"),
    12: .standard(proto: "unbatched_transfers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._params)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.lastObservedNonce)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.valsets)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.valsetConfirms)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.batches)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.batchConfirms)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.logicCalls)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.logicCallConfirms)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.attestations)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.delegateKeys)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.erc20ToDenoms)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.unbatchedTransfers)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.lastObservedNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastObservedNonce, fieldNumber: 2)
    }
    if !self.valsets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valsets, fieldNumber: 3)
    }
    if !self.valsetConfirms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.valsetConfirms, fieldNumber: 4)
    }
    if !self.batches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.batches, fieldNumber: 5)
    }
    if !self.batchConfirms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.batchConfirms, fieldNumber: 6)
    }
    if !self.logicCalls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logicCalls, fieldNumber: 7)
    }
    if !self.logicCallConfirms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logicCallConfirms, fieldNumber: 8)
    }
    if !self.attestations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attestations, fieldNumber: 9)
    }
    if !self.delegateKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.delegateKeys, fieldNumber: 10)
    }
    if !self.erc20ToDenoms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.erc20ToDenoms, fieldNumber: 11)
    }
    if !self.unbatchedTransfers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unbatchedTransfers, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_GenesisState, rhs: Gravity_V1_GenesisState) -> Bool {
    if lhs._params != rhs._params {return false}
    if lhs.lastObservedNonce != rhs.lastObservedNonce {return false}
    if lhs.valsets != rhs.valsets {return false}
    if lhs.valsetConfirms != rhs.valsetConfirms {return false}
    if lhs.batches != rhs.batches {return false}
    if lhs.batchConfirms != rhs.batchConfirms {return false}
    if lhs.logicCalls != rhs.logicCalls {return false}
    if lhs.logicCallConfirms != rhs.logicCallConfirms {return false}
    if lhs.attestations != rhs.attestations {return false}
    if lhs.delegateKeys != rhs.delegateKeys {return false}
    if lhs.erc20ToDenoms != rhs.erc20ToDenoms {return false}
    if lhs.unbatchedTransfers != rhs.unbatchedTransfers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
